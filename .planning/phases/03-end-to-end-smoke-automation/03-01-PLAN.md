---
phase: 03-end-to-end-smoke-automation
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/reliability/smoke/fixture-matrix.js
  - src/reliability/smoke/run-smoke-suite.js
  - src/reliability/smoke/reporting.js
  - scripts/smoke-reliability.mjs
autonomous: true
requirements:
  - RELY-03
  - RELY-05
must_haves:
  truths:
    - "Smoke run verifies the real extraction path country -> league -> season -> match for representative fixtures"
    - "Every fixture in the smoke matrix produces an explicit pass/fail record with failure stage and reason"
    - "Smoke command always writes a machine-readable JSON artifact before exit"
  artifacts:
    - "src/reliability/smoke/fixture-matrix.js defines bounded representative fixtures and sample controls"
    - "src/reliability/smoke/run-smoke-suite.js executes traversal and extraction checks per fixture"
    - "src/reliability/smoke/reporting.js writes latest artifact with per-fixture outcomes and summary"
    - "scripts/smoke-reliability.mjs exposes runnable CLI smoke command"
  key_links:
    - "fixture matrix -> smoke runner traversal pipeline -> per-fixture result object"
    - "runner result object -> reporting writer -> .planning/artifacts/smoke/latest.json"
    - "CLI args -> runner options (sample/max/timeout) -> deterministic runtime budget"
---

<objective>
Build the core reliability smoke runner that validates representative extraction paths and writes per-fixture machine-readable outcomes.

Purpose: Provide deterministic local automation that catches extraction-path regressions early with actionable diagnostics.
Output: Fixture matrix, runnable smoke command, and JSON artifact output with per-fixture status.
</objective>

<execution_context>
@./.codex/get-shit-done/workflows/execute-plan.md
@./.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/03-end-to-end-smoke-automation/03-RESEARCH.md

@src/scraper/services/countries/index.js
@src/scraper/services/leagues/index.js
@src/scraper/services/seasons/index.js
@src/scraper/services/matches/index.js
@src/constants/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define representative fixture matrix and traversal contract</name>
  <files>src/reliability/smoke/fixture-matrix.js, src/reliability/smoke/run-smoke-suite.js</files>
  <action>Create a bounded fixture matrix (country slug + league season slug + fixture hint) and implement a runner contract that executes the same extraction path used in production (`getListOfCountries` -> `getListOfLeagues` -> `getListOfSeasons` -> `getMatchLinks` + `getMatchData`). Include runner options for sample size and max matches per fixture to keep smoke runtime CI-safe.</action>
  <verify><automated>node --check src/reliability/smoke/fixture-matrix.js src/reliability/smoke/run-smoke-suite.js</automated></verify>
  <done>Runner can evaluate each configured fixture and return structured step-level outcomes without duplicating scraping logic.</done>
</task>

<task type="auto">
  <name>Task 2: Implement per-fixture diagnostics and artifact writer</name>
  <files>src/reliability/smoke/run-smoke-suite.js, src/reliability/smoke/reporting.js</files>
  <action>Capture per-fixture result payloads with `fixtureId`, `status`, `failedStage`, `error`, `durationMs`, and key counters (countries/leagues/seasons/matches discovered). Write aggregate artifact JSON to `.planning/artifacts/smoke/latest.json` and timestamped history file so each smoke run is machine-readable and auditable.</action>
  <verify><automated>node --check src/reliability/smoke/run-smoke-suite.js src/reliability/smoke/reporting.js</automated></verify>
  <done>Smoke run always emits deterministic artifact structure with summary and per-fixture details, even when failures occur.</done>
</task>

<task type="auto">
  <name>Task 3: Expose local smoke CLI entrypoint with bounded runtime flags</name>
  <files>scripts/smoke-reliability.mjs, src/reliability/smoke/run-smoke-suite.js</files>
  <action>Create a CLI entrypoint that runs the smoke suite, prints concise fixture summary, and exits non-zero on any fixture failure. Support flags such as `--sample`, `--max-matches`, `--fixture`, and `--dry-run` to control runtime budget and debug path behavior without full matrix execution.</action>
  <verify><automated>node --check scripts/smoke-reliability.mjs src/reliability/smoke/run-smoke-suite.js</automated></verify>
  <done>Developers can run the smoke command locally and receive deterministic pass/fail plus artifact output for selected fixtures.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] node --check src/reliability/smoke/fixture-matrix.js src/reliability/smoke/run-smoke-suite.js src/reliability/smoke/reporting.js scripts/smoke-reliability.mjs
- [ ] node scripts/smoke-reliability.mjs --dry-run --sample 1
- [ ] test -f .planning/artifacts/smoke/latest.json
- [ ] node -e "const fs=require('fs');const p='.planning/artifacts/smoke/latest.json';const r=JSON.parse(fs.readFileSync(p,'utf8'));if(!Array.isArray(r.fixtures))process.exit(1);"
</verification>

<success_criteria>

- All plan tasks completed
- Representative fixture matrix validates extraction path traversal
- Machine-readable artifact includes per-fixture pass/fail and failure diagnostics
- Local smoke command supports bounded execution for routine development use
</success_criteria>

<output>
After completion, create .planning/phases/03-end-to-end-smoke-automation/03-01-SUMMARY.md
</output>
