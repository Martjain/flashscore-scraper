---
phase: 05-reliability-failure-alerts
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/reliability/alerts/config.js
  - src/reliability/alerts/payload.js
  - src/reliability/alerts/publisher.js
  - src/reliability/alerts/index.js
autonomous: true
requirements:
  - RELY-08
must_haves:
  truths:
    - "Failing runs can produce exactly one structured failure alert payload per run/source"
    - "Alert payload always includes run identity, normalized source, stage/scope context, and affected identifiers"
    - "Alert delivery failures are observable via warning metadata without becoming fatal command failures"
  artifacts:
    - "src/reliability/alerts/config.js centralizes enablement rules (CI-only default + webhook presence)"
    - "src/reliability/alerts/payload.js builds fixed-schema, versioned failure payloads from smoke/selector-health result objects"
    - "src/reliability/alerts/publisher.js sends webhook payloads with timeout and returns non-throwing delivery status"
    - "src/reliability/alerts/index.js exposes the stable alerting API used by scripts"
  key_links:
    - "command result object -> payload builder normalization -> fixed webhook payload"
    - "environment config + run result -> shouldSendFailureAlert gate -> send/no-send decision"
    - "publisher send outcome -> warning metadata -> caller logging without exit-code override"
---

<objective>
Implement a shared failure-alerting foundation for reliability commands.

Purpose: Provide one reusable alerting contract for smoke and selector-health so both commands emit consistent, low-noise, machine-readable failure notifications.
Output: Alert config gate, normalized payload builder, and non-blocking webhook publisher module.
</objective>

<execution_context>
@./.codex/get-shit-done/workflows/execute-plan.md
@./.codex/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/05-reliability-failure-alerts/05-CONTEXT.md
@.planning/phases/05-reliability-failure-alerts/05-RESEARCH.md

@scripts/smoke-reliability.mjs
@scripts/health-selectors.mjs
@src/reliability/smoke/run-smoke-suite.js
@src/selector-health/health-check/runSelectorHealthCheck.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define alert enablement and CI-only default policy</name>
  <files>src/reliability/alerts/config.js, src/reliability/alerts/index.js</files>
  <action>Create alert config helpers that derive whether a failure alert should be attempted based on run result (`fail` only), webhook configuration presence, and CI-only default behavior. Keep defaults aligned with context decisions: success runs produce no routine alerts, local runs do not alert unless explicitly overridden, and no severity threshold is introduced.</action>
  <verify><automated>node --check src/reliability/alerts/config.js src/reliability/alerts/index.js</automated></verify>
  <done>Callers can deterministically compute `enabled/disabled` alert status with machine-readable reasons before any payload or network call.</done>
</task>

<task type="auto">
  <name>Task 2: Build normalized fixed-schema failure payload contract</name>
  <files>src/reliability/alerts/payload.js, src/reliability/alerts/index.js</files>
  <action>Implement payload builders for smoke and selector-health sources that emit a single structured JSON contract with version field, normalized source enum, UTC timestamps, one-line summary, run ID, stage/scope fields, and deterministic affected identifiers. Include full identifier lists (sorted), explicit empty list + reason when no fixture IDs exist, and optional artifact/log references when available.</action>
  <verify><automated>node --check src/reliability/alerts/payload.js src/reliability/alerts/index.js</automated></verify>
  <done>Both source adapters produce payloads that satisfy RELY-08 fields and locked context decisions without source-specific schema drift.</done>
</task>

<task type="auto">
  <name>Task 3: Add non-blocking webhook publisher with timeout and send diagnostics</name>
  <files>src/reliability/alerts/publisher.js, src/reliability/alerts/index.js</files>
  <action>Create webhook delivery helper that POSTs JSON payloads with bounded timeout, returns structured send status (`sent`, `statusCode`, `error`, `durationMs`), and never throws fatal errors to callers. Ensure this module supports warning-friendly diagnostics so command scripts can log alert failures while preserving their own pass/fail exit semantics.</action>
  <verify><automated>node --check src/reliability/alerts/publisher.js src/reliability/alerts/index.js</automated></verify>
  <done>Scripts can attempt alert delivery and reliably receive non-fatal send outcome metadata, including timeout/HTTP failure cases.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] node --check src/reliability/alerts/config.js src/reliability/alerts/payload.js src/reliability/alerts/publisher.js src/reliability/alerts/index.js
- [ ] node -e "import('./src/reliability/alerts/payload.js').then(({buildFailureAlertPayload})=>{const p=buildFailureAlertPayload({source:'smoke',result:{runId:'smoke-1',result:'fail',issues:[{fixtureId:'a',failedStage:'matches',error:'timeout'}],summary:{failedFixtures:1,totalFixtures:1},fixtures:[{fixtureId:'a',status:'fail',failedStage:'matches',error:'timeout'}]},metadata:{artifactPath:'.planning/artifacts/smoke/latest.json'}});if(!p||p.source!=='smoke'||!p.runId||!Array.isArray(p.affectedIdentifiers))process.exit(1);}).catch(()=>process.exit(1));"
- [ ] node -e "import('./src/reliability/alerts/config.js').then(({shouldSendFailureAlert})=>{const ciFail=shouldSendFailureAlert({runResult:'fail',env:{CI:'true',RELIABILITY_ALERT_WEBHOOK_URL:'https://example.test'}});const ciPass=shouldSendFailureAlert({runResult:'pass',env:{CI:'true',RELIABILITY_ALERT_WEBHOOK_URL:'https://example.test'}});if(!ciFail.enabled||ciPass.enabled)process.exit(1);}).catch(()=>process.exit(1));"
</verification>

<success_criteria>

- All plan tasks completed
- Shared alert module enforces CI-only, failure-only default trigger behavior
- Fixed payload contract includes required run/source/stage/scope/identifier context
- Webhook send outcomes are non-blocking and usable for warning logs
</success_criteria>

<output>
After completion, create .planning/phases/05-reliability-failure-alerts/05-01-SUMMARY.md
</output>
